@page "/richedit-compress"
@using System
@using System.IO
@using System.Text
@using System.Text.RegularExpressions
@using System.Drawing
@using System.Drawing.Imaging
@using DevExpress.Blazor
@using DevExpress.Blazor.RichEdit
@using ImageMagick
@inject IJSRuntime JS

<div class="mb-3">
    <DxButton Text="Save (Compress Images)" Click="@SaveCompressedHtml" CssClass="me-2" />
    <DxButton Text="Load Saved Content" Click="@LoadContent" />
</div>

<DxRichEdit @ref="richEdit"
            DocumentLoaded="OnDocumentLoaded"
            CustomizeToolbar="OnCustomizeToolbar"
            DocumentFormat="DocumentFormat.Rtf"
            DocumentContent="@editorContentBytes"
            CheckSpelling="true"
            BarMode="BarMode.Toolbar"
            CssClass="w-100 txtEditorMsg"
            ViewType="ViewType.Simple"
            Height="500px" />

@if (isSaving)
{
    <div class="p-3">
        <DxProgressBar Value="@progressValue"
                       Min="0"
                       Max="100"
                       ShowLabel="true"
                       ShowValue="true"
                       DisplayFormat="Processing... {0}%"
                       Width="100%" />
    </div>
}


@((MarkupString)savedHtml)

@code {
    [Inject] IAppToastService AppToast { get; set; }

    bool isSaving = false;
    int progressValue = 0;

    DxRichEdit richEdit;

    string savedHtml; // Simulated DB (varchar(MAX))
    byte[] editorContentBytes;

    protected override async Task OnInitializedAsync()
    {
        await LoadContent();
    }

    private async Task LoadContent()
    {
        //string html = savedHtml ?? "<p>Paste an image here and click 'Save'</p>";
        //editorContentBytes = Encoding.UTF8.GetBytes(html);
        //await richEdit.LoadDocumentAsync(editorContentBytes, DocumentFormat.Html);
        //string htmlContent1 = System.Text.Encoding.UTF8.GetString(htmlBinaryData1);
        
    }

    async void OnCustomizeToolbar(IToolbar toolbar)
    {
        BarGroupCollection groups = toolbar.Groups;
        toolbar.Groups.Clear();


        // Inserts the File group at the first position in the group collection
        //toolbar.Groups.Add(0, RichEditToolbarGroupNames.File);
        toolbar.Groups.Add(0, RichEditToolbarGroupNames.Undo);
        toolbar.Groups.Add(1, RichEditToolbarGroupNames.Font);
        toolbar.Groups.Add(2, RichEditToolbarGroupNames.Paragraph);
        toolbar.Groups.Add(3, RichEditToolbarGroupNames.Picture);
        toolbar.Groups.Add(4, RichEditToolbarGroupNames.Table);



        IBarGroup clipboardGroup = toolbar.Groups[1];
        clipboardGroup.Items.Add(5, RichEditBarItemNames.FontUnderline);
        clipboardGroup.Items.Add(6, RichEditBarItemNames.HighlightText);
        clipboardGroup.Items.Add(7, RichEditBarItemNames.ClipboardMenu);
        clipboardGroup.Items.Add(8, RichEditBarItemNames.ClearFormatting);
        clipboardGroup.Items.Add(9, RichEditBarItemNames.FontStrikeout);
        clipboardGroup.Items.Add(10, RichEditBarItemNames.FontScriptMenu);


        IBarGroup replace = toolbar.Groups[4];
        replace.Items.Add(1, RichEditBarItemNames.ChangeCaseMenu);
        replace.Items.Add(2, RichEditBarItemNames.Replace);


        //AddFormattingGroup(groups);


        IBarGroup fontGroup = toolbar.Groups[RichEditToolbarGroupNames.Font];
      

        IBarGroup undoRedoGroup = toolbar.Groups[0];
        undoRedoGroup.Items.Add(0, RichEditBarItemNames.FullScreen);

       
    }

    private void OnDocumentLoaded() { }

    private async Task SaveCompressedHtml()
    {
        try
        {
            isSaving = true;
            progressValue = 0;
            StateHasChanged();

            // 1. Export document to HTML
            progressValue = 10;
            StateHasChanged();

            byte[] fileContent = await richEdit.ExportDocumentAsync(DocumentFormat.Rtf);

            using var server = new DevExpress.XtraRichEdit.RichEditDocumentServer();
            server.LoadDocument(fileContent);
            server.Options.Export.Html.EmbedImages = true;
            byte[] fileContents = server.SaveDocument(DevExpress.XtraRichEdit.DocumentFormat.Html);

            string htmlContent = Encoding.UTF8.GetString(fileContents);

            // 2. Compress with progress
            savedHtml = CompressBase64ImagesInHtmlWithProgress(htmlContent, 800);

            // 3. Finish
            progressValue = 100;
            StateHasChanged();

            AppToast.ShowSuccess("HTML saved with compressed images!");
        }
        catch (Exception ex)
        {
            AppToast.ShowError($"Error while saving: {ex.Message}");
        }
        finally
        {
            await Task.Delay(500); // Small delay so user sees 100%
            isSaving = false;
            StateHasChanged();
        }
    }

    private string CompressBase64ImagesInHtmlWithProgress(string htmlContent, int maxWidth = 800)
    {
        var imgRegex = new Regex("<img[^>]*src=[\"']data:image/(?<type>[^;]+);base64,(?<data>[^\"']+)[\"'][^>]*>", RegexOptions.IgnoreCase);
        var matches = imgRegex.Matches(htmlContent);

        int total = matches.Count;
        int processed = 0;

        return imgRegex.Replace(htmlContent, match =>
        {
            try
            {
                string base64 = match.Groups["data"].Value;
                byte[] imageBytes = Convert.FromBase64String(base64);

                using var image = new MagickImage(imageBytes);

                if (image.Width > maxWidth)
                {
                    int newHeight = (int)(image.Height * (maxWidth / (double)image.Width));
                    image.Resize(maxWidth, newHeight);
                }

                image.Format = MagickFormat.Png;
                image.Strip();

                byte[] compressedBytes = image.ToByteArray();
                string compressedBase64 = Convert.ToBase64String(compressedBytes);

                return $"<img src=\"data:image/png;base64,{compressedBase64}\" />";
            }
            catch
            {
                return match.Value;
            }
            finally
            {
                processed++;
                progressValue = 10 + (int)((processed / (double)total) * 90); // from 10% to 100%
                InvokeAsync(StateHasChanged);
            }
        });
    }


    public string CompressBase64ImagesInHtml(string htmlContent, int maxWidth = 800)
    {
        var imgRegex = new Regex("<img[^>]*src=[\"']data:image/(?<type>[^;]+);base64,(?<data>[^\"']+)[\"'][^>]*>", RegexOptions.IgnoreCase);

        return imgRegex.Replace(htmlContent, match =>
        {
            string type = match.Groups["type"].Value.ToLower();
            string base64 = match.Groups["data"].Value;

            try
            {
                byte[] imageBytes = Convert.FromBase64String(base64);
                using var image = new MagickImage(imageBytes);

                // Resize if too large
                if (image.Width > maxWidth)
                {
                    int newHeight = (int)(image.Height * (maxWidth / (double)image.Width));
                    image.Resize(maxWidth, newHeight);
                }

                // Force to PNG format (faster, lossless compression)
                image.Format = MagickFormat.Png;
                image.Strip(); // Remove metadata (smaller file)

                byte[] compressedBytes = image.ToByteArray();
                string compressedBase64 = Convert.ToBase64String(compressedBytes);

                return $"<img src=\"data:image/png;base64,{compressedBase64}\" />";
            }
            catch
            {
                return match.Value;
            }
        });
    }


    public string CompressBase64ImagesInHtml_v(string htmlContent, int maxWidth = 800, int quality = 60)
    {
        var imgRegex = new Regex("<img[^>]*src=[\"']data:image/(?<type>[^;]+);base64,(?<data>[^\"']+)[\"'][^>]*>", RegexOptions.IgnoreCase);

        return imgRegex.Replace(htmlContent, match =>
        {
            string type = match.Groups["type"].Value;
            string base64 = match.Groups["data"].Value;

            try
            {
                byte[] imageBytes = Convert.FromBase64String(base64);
                using var inputStream = new MemoryStream(imageBytes);
                using var image = System.Drawing.Image.FromStream(inputStream);

                // Resize if necessary
                int newWidth = image.Width > maxWidth ? maxWidth : image.Width;
                int newHeight = (int)(image.Height * (newWidth / (double)image.Width));

                using var resized = new Bitmap(image, new Size(newWidth, newHeight));
                using var outputStream = new MemoryStream();

                var jpegEncoder = ImageCodecInfo.GetImageDecoders().First(c => c.FormatID == ImageFormat.Jpeg.Guid);
                var encoderParams = new EncoderParameters(1);
                encoderParams.Param[0] = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, (long)quality);

                resized.Save(outputStream, jpegEncoder, encoderParams);
                string compressedBase64 = Convert.ToBase64String(outputStream.ToArray());

                return $"<img src=\"data:image/jpeg;base64,{compressedBase64}\" />";
            }
            catch
            {
                // On failure, return original image tag
                return match.Value;
            }
        });
    }
}
