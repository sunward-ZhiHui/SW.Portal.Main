@page "/richedit-compress-paste"
@using System.Text
@using System.Text.RegularExpressions
@using System.IO
@using System.Drawing.Imaging
@inject IJSRuntime JSRuntime

<DxRichEdit @ref="richEdit"
            DocumentLoaded="OnDocumentLoaded"
            CustomizeToolbar="OnCustomizeToolbar"
            DocumentFormat="DocumentFormat.OpenXml"
            DocumentContent="@editorContentBytes"
            CheckSpelling="true"
            BarMode="BarMode.Toolbar"
            CssClass="w-100 txtEditorMsg"
            ViewType="ViewType.Simple"
            Height="500px"
            Id="myRichEdit" />


<div class="mt-2">
    <DxButton Text="Save" Click="@OnSaveWithLoading" Enabled="!isSaving" />
     @if (showElapsed)
    {
        @if (isSaving)
        {
            <span class="ml-2 text-info">
                <i class="fas fa-spinner fa-spin"></i> Saving... @elapsedSeconds s
            </span>
        }
    }
</div>



@* <DxButton Text="Save" Click="@OnSave" /> *@


@((MarkupString)savedHtml)

@code {
    string savedHtml;
    DxRichEdit richEdit;
    byte[] editorContentBytes;


    bool isSaving = false;
    bool showElapsed = false;
    int elapsedSeconds = 0;
    System.Timers.Timer saveTimer;

    async void OnCustomizeToolbar(IToolbar toolbar)
    {
        toolbar.Groups.Clear();
        toolbar.Groups.Add(0, RichEditToolbarGroupNames.Undo);
        toolbar.Groups.Add(1, RichEditToolbarGroupNames.Font);
        toolbar.Groups.Add(2, RichEditToolbarGroupNames.Paragraph);
        toolbar.Groups.Add(3, RichEditToolbarGroupNames.Picture);
        toolbar.Groups.Add(4, RichEditToolbarGroupNames.Table);

        IBarGroup clipboardGroup = toolbar.Groups[1];
        clipboardGroup.Items.Add(5, RichEditBarItemNames.FontUnderline);
        clipboardGroup.Items.Add(6, RichEditBarItemNames.HighlightText);
        clipboardGroup.Items.Add(7, RichEditBarItemNames.ClipboardMenu);
        clipboardGroup.Items.Add(8, RichEditBarItemNames.ClearFormatting);
        clipboardGroup.Items.Add(9, RichEditBarItemNames.FontStrikeout);
        clipboardGroup.Items.Add(10, RichEditBarItemNames.FontScriptMenu);

        IBarGroup replace = toolbar.Groups[4];
        replace.Items.Add(1, RichEditBarItemNames.ChangeCaseMenu);
        replace.Items.Add(2, RichEditBarItemNames.Replace);

        IBarGroup undoRedoGroup = toolbar.Groups[0];
        undoRedoGroup.Items.Add(0, RichEditBarItemNames.FullScreen);
    }

    private async void OnDocumentLoaded()
    {
        // Attach JS paste event listener once the document is ready
        await JSRuntime.InvokeVoidAsync("attachPasteHandler", DotNetObjectReference.Create(this));
    }

    [JSInvokable]
    public async Task OnImagePasted()
    {
        await ResizeAllImages();
    }

    async Task ResizeAllImages()
    {
        try
        {
            var documentAPI = richEdit.DocumentAPI;
            var inlineImages = await documentAPI.InlineImages.GetAllAsync();
            foreach (var img in inlineImages)
            {
                await img.ChangePropertiesAsync(properties =>
                {
                    properties.ActualSize.Width = UnitConverter.PointsToTwips(150);
                    properties.ActualSize.Height = UnitConverter.PointsToTwips(150);
                });
            }
            Console.WriteLine($"Resized {inlineImages.Count} images.");
        }
        catch (OperationCanceledException ex)
        {
            Console.WriteLine($"Resize canceled: {ex.Message}");
        }
    }

    private static readonly DevExpress.XtraRichEdit.RichEditDocumentServer SharedServer = new DevExpress.XtraRichEdit.RichEditDocumentServer();

    async Task OnSave_1()
    {
        // 1) Export from DxRichEdit as DOCX (Blazor enum!)
        byte[] docx = await richEdit.ExportDocumentAsync(DevExpress.Blazor.RichEdit.DocumentFormat.OpenXml);

        // 2) Convert to HTML with embedded images (XtraRichEdit enums/options!)
        byte[] htmlBytes;
        lock (SharedServer) // RichEditDocumentServer is not thread-safe
        {
            SharedServer.LoadDocument(docx, DevExpress.XtraRichEdit.DocumentFormat.OpenXml);

            SharedServer.Options.Export.Html.EmbedImages = true;
            SharedServer.Options.Export.Html.CssPropertiesExportType =
                DevExpress.XtraRichEdit.Export.Html.CssPropertiesExportType.Inline;
            SharedServer.Options.Export.Html.ExportRootTag =
                DevExpress.XtraRichEdit.Export.Html.ExportRootTag.Body;

            htmlBytes = SharedServer.SaveDocument(DevExpress.XtraRichEdit.DocumentFormat.Html);
        }

        savedHtml = Encoding.UTF8.GetString(htmlBytes);
        StateHasChanged();
    }
    async Task OnSave()
    {
        // 1) Export from DxRichEdit as DOCX
        byte[] docx = await richEdit.ExportDocumentAsync(DevExpress.Blazor.RichEdit.DocumentFormat.OpenXml);

        // 2) Convert to HTML with embedded images
        byte[] htmlBytes;
        lock (SharedServer) // RichEditDocumentServer is not thread-safe
        {
            SharedServer.LoadDocument(docx, DevExpress.XtraRichEdit.DocumentFormat.OpenXml);

            SharedServer.Options.Export.Html.EmbedImages = true;
            SharedServer.Options.Export.Html.CssPropertiesExportType =
                DevExpress.XtraRichEdit.Export.Html.CssPropertiesExportType.Inline;
            SharedServer.Options.Export.Html.ExportRootTag =
                DevExpress.XtraRichEdit.Export.Html.ExportRootTag.Body;

            htmlBytes = SharedServer.SaveDocument(DevExpress.XtraRichEdit.DocumentFormat.Html);
        }

        // 3) Convert HTML to string
        string htmlContent = Encoding.UTF8.GetString(htmlBytes);

        // 4) Compress base64 images inside HTML
        string compressedHtml = CompressHtmlImages(htmlContent);

        // 5) Save result
        savedHtml = compressedHtml;

        StateHasChanged();
    }


    async Task OnSaveWithLoading()
    {
        isSaving = true;
        showElapsed = true;
        elapsedSeconds = 0;
        StateHasChanged();

        // Start timer
        saveTimer = new System.Timers.Timer(1000);
        saveTimer.Elapsed += (s, e) =>
        {
            elapsedSeconds++;
            InvokeAsync(StateHasChanged);
        };
        saveTimer.Start();

        try
        {
            await OnSave();
        }
        finally
        {
            saveTimer.Stop();
            // Timer disposed only after UI update to ensure final value shows
            //isSaving = false;
            StateHasChanged();
            //await Task.Delay(3000); // Keep "Saved in X s" for 3 seconds
            //showElapsed = false;
            //saveTimer.Dispose();
            StateHasChanged();
        }
    }

    async Task OnSave_v()
    {
        // Get latest HTML from RichEdit
        byte[] fileContent = await richEdit.ExportDocumentAsync(DocumentFormat.Rtf);
        using var server = new DevExpress.XtraRichEdit.RichEditDocumentServer();
        server.LoadDocument(fileContent);
        server.Options.Export.Html.EmbedImages = true;
        byte[] fileContents = server.SaveDocument(DevExpress.XtraRichEdit.DocumentFormat.Html);

        string htmlContent = Encoding.UTF8.GetString(fileContents);
       
        string compressedHtml = CompressHtmlImages(htmlContent);

        savedHtml = compressedHtml;
        StateHasChanged();
        
    }

    private string CompressHtmlImages(string htmlContent)
    {
        var imgRegex = new Regex(
            @"<img[^>]+src=[""']data:image/(?<type>[^;]+);base64,(?<data>[^""']+)[""'][^>]*>",
            RegexOptions.IgnoreCase | RegexOptions.Singleline);

        var newHtml = imgRegex.Replace(htmlContent, match =>
        {
            string base64Data = match.Groups["data"].Value;

            try
            {
                byte[] imageBytes = Convert.FromBase64String(base64Data);

                using var inputStream = new MemoryStream(imageBytes);
                using var originalImage = System.Drawing.Image.FromStream(inputStream);

                // 1️⃣ Resize image (max 800px in width/height to cut down size)
                int maxDimension = 800;
                int newWidth = originalImage.Width;
                int newHeight = originalImage.Height;

                if (newWidth > maxDimension || newHeight > maxDimension)
                {
                    double ratioX = (double)maxDimension / originalImage.Width;
                    double ratioY = (double)maxDimension / originalImage.Height;
                    double ratio = Math.Min(ratioX, ratioY);

                    newWidth = (int)(originalImage.Width * ratio);
                    newHeight = (int)(originalImage.Height * ratio);
                }

                using var resizedImage = new System.Drawing.Bitmap(originalImage, newWidth, newHeight);

                // 2️⃣ Convert to JPEG with aggressive compression
                using var outputStream = new MemoryStream();
                var jpegEncoder = GetEncoder(ImageFormat.Jpeg);
                var encParams = new EncoderParameters(1);
                encParams.Param[0] = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, 40L); // lower = smaller size

                resizedImage.Save(outputStream, jpegEncoder, encParams);

                byte[] compressedBytes = outputStream.ToArray();
                string newBase64 = Convert.ToBase64String(compressedBytes);

                // 3️⃣ Replace with smaller JPEG
                return match.Value
                            .Replace(base64Data, newBase64)
                            .Replace(match.Groups["type"].Value, "jpeg");
            }
            catch
            {
                return match.Value;
            }
        });

        return newHtml;
    }

    private static ImageCodecInfo GetEncoder(ImageFormat format)
    {
        return ImageCodecInfo.GetImageDecoders().FirstOrDefault(c => c.FormatID == format.Guid);
    }



    private string CompressHtmlImages_v(string htmlContent)
    {
        var imgRegex = new Regex(
            @"<img[^>]+src=[""']data:image/(?<type>[^;]+);base64,(?<data>[^""']+)[""'][^>]*>",
            RegexOptions.IgnoreCase | RegexOptions.Singleline);

        var newHtml = imgRegex.Replace(htmlContent, match =>
        {
            string imageType = match.Groups["type"].Value;
            string base64Data = match.Groups["data"].Value;

            try
            {
                byte[] imageBytes = Convert.FromBase64String(base64Data);

                using var inputStream = new MemoryStream(imageBytes);
                using var image = System.Drawing.Image.FromStream(inputStream);

                using var outputStream = new MemoryStream();
                var encoder = GetEncoder_v(ImageFormat.Jpeg);
                var encParams = new EncoderParameters(1);
                encParams.Param[0] = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, 50L);

                image.Save(outputStream, encoder, encParams);
                byte[] compressedBytes = outputStream.ToArray();

                string newBase64 = Convert.ToBase64String(compressedBytes);
                return match.Value.Replace(base64Data, newBase64)
                                  .Replace(imageType, "jpeg");
            }
            catch
            {
                return match.Value; // keep original if something fails
            }
        });

        return newHtml;
    }

    private static ImageCodecInfo GetEncoder_v(ImageFormat format)
    {
        return ImageCodecInfo.GetImageDecoders().FirstOrDefault(c => c.FormatID == format.Guid);
    }      
}
