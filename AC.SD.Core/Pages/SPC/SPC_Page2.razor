@using System.Drawing
@inject ChartService chartService

@* <h3 style="text-align: center;">SPC Chart Builder Finished Product</h3> *@

<style scoped>
    .accordion {
        border: 1px solid #ccc;
        border-radius: 8px;
        margin: 10px 0;
        overflow: hidden;
    }

    .accordion-header {
        padding: 12px;
        font-weight: bold;
        cursor: pointer;
        background: #f1f1f1;
        transition: background 0.3s;
    }

        .accordion-header:hover {
            background: #e5e5e5;
        }

    .accordion-content {
        padding: 12px;
        background: #fafafa;
        border-top: 1px solid #ccc;
        animation: fadeIn 0.3s ease-in-out;
    }
   
</style>


<div class="accordion">
    <div class="accordion-header" @onclick="ToggleAccordion">
        <span>@(isOpen ? "▼ " : "► ") Finished Product</span>
    </div>

    @if (isOpen)
    {
        <div style="padding:10px;">
            <div class="row mb-2 mt-4">
                <div class="col-md-4">
                    <label> Select Table </label>
                    <DxComboBox T="string"
                                SearchMode="ListSearchMode.AutoSearch"
                                SearchFilterCondition="ListSearchFilterCondition.Contains"
                                Data="@tableList"
                                Value="@selectedTable"
                                ValueChanged="@((string? newValue) => OnTableChanged(newValue))"
                                NullText="Select Table" />
                </div>
                <div class="col-md-8">
                    @if (columnList?.Count > 0)
                    {
                        <div class="row">
                            <div class="col-md-4">
                                <label> Select X Axis </label>
                                <DxComboBox T="string"
                                            SearchMode="ListSearchMode.AutoSearch"
                                            SearchFilterCondition="ListSearchFilterCondition.Contains"
                                            Data="@columnList"
                                            Value="@xField"
                                            ValueChanged="@((string? newValue) => { xField = newValue; CheckAxesSelected(); })"
                                            NullText="Select X-Axis" />
                            </div>
                            <div class="col-md-4">
                                <label> Select Y Axis </label>
                                <DxComboBox T="string"
                                            SearchMode="ListSearchMode.AutoSearch"
                                            SearchFilterCondition="ListSearchFilterCondition.Contains"
                                            Data="@columnList"
                                            Value="@yField"
                                            ValueChanged="@((string? newValue) => { yField = newValue; CheckAxesSelected(); })"
                                            NullText="Select Y-Axis" />
                            </div>
                            <div class="col-md-4">
                                <label> Select Date Column </label>
                                <DxComboBox T="string"
                                            SearchMode="ListSearchMode.AutoSearch"
                                            SearchFilterCondition="ListSearchFilterCondition.Contains"
                                            Data="@dateColumnList"
                                            Value="@dateField"
                                            ValueChanged="@((string? newValue) => { dateField = newValue; CheckAxesSelected(); })"
                                            NullText="Select Date Column" />
                            </div>
                        </div>
                    }
                </div>

            </div>
            <div class="row mb-2 mt-4">
                <div class="col-md-8">
                    <div class="row">
                        <div class="col-md-3">
                            <label>LSL Value</label>
                            <DxSpinEdit @bind-Value="LSL" NullText="LSL" />
                        </div>
                        <div class="col-md-3">
                            <label>USL Value</label>
                            <DxSpinEdit @bind-Value="USL" NullText="USL" />
                        </div>
                        <div class="col-md-3">
                            <label>UCL Value</label>
                            <DxSpinEdit @bind-Value="UCL" NullText="UCL" />
                        </div>
                        <div class="col-md-3">
                            <label>LCL Value</label>
                            <DxSpinEdit @bind-Value="LCL" NullText="LCL" />
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="row">
                        <div class="col-md-4">
                            <label>Sigma 1</label>
                            <DxSpinEdit @bind-Value="Sig1" NullText="Sigma -1" />
                        </div>

                        <div class="col-md-4">
                            <label>Sigma 2</label>
                            <DxSpinEdit @bind-Value="Sig2" NullText="Sigma -2" />
                        </div>

                        <div class="col-md-4">
                            <label>Sigma 3</label>
                            <DxSpinEdit @bind-Value="Sig3" NullText="Sigma -3" />
                        </div>
                    </div>
                </div>
            </div>
            <div class="row mb-2 mt-4">

                <div class="col-md-4">
                    <div class="row">

                        <div class="col-md-12">
                            <label>Draw Limits On:</label>
                            <DxComboBox T="string"
                                        Data="@limitAxisOptions"
                                        @bind-Value="limitAxis"
                                        NullText="Select Axis" />
                        </div>

                    </div>

                </div>
                <div class="col-md-8">
                    <div class="row">
                        <div class="col-md-4">
                            <label>Chart Title</label>
                            <DxTextBox @bind-Text="chartTitle" NullText="Chart Title" />
                        </div>
                        <div class="col-md-4">
                            <label>X Axis</label>
                            <DxTextBox @bind-Text="xAxisLabel" NullText="X Axis Label" />
                        </div>
                        <div class="col-md-4">
                            <label>Y Axis</label>
                            <DxTextBox @bind-Text="yAxisLabel" NullText="Y Axis Label" />
                        </div>
                    </div>
                </div>

            </div>
            <div class="row mb-2 mt-4">
                <div class="col-md-2">
                    <label>Start Date:</label>
                    <DxDateEdit @bind-Date="startDate"
                                MinDate="minDate ?? DateTime.Today.AddYears(-10)"
                                MaxDate="maxDate ?? DateTime.Today.AddYears(10)" />
                </div>
                <div class="col-md-2">
                    <label>End Date:</label>
                    <DxDateEdit @bind-Date="endDate"
                                MinDate="minDate ?? DateTime.Today.AddYears(-10)"
                                MaxDate="maxDate ?? DateTime.Today.AddYears(10)" />
                </div>
                <div class="col-md-3 align-self-end">
                    <DxButton Text="Apply Date Filter" Click="ApplyDateFilter" />
                </div>
            </div>
        </div>

        

    }
</div>

<!-- Chart Spec + Labels -->
@if (processedData?.Count > 0)
{
    <DxChart Data="processedData" Width="100%" Height="500px">
        <DxChartTitle Text="@($"{chartTitle} | Avg={avg:F3}, LSL={LSL:F3}, USL={USL:F3},UCL={UCL:F3}, LCL={LCL:F3}")" />
        <DxChartLegend HorizontalAlignment="HorizontalAlignment.Right"
                       Position="RelativePosition.Outside"
                       VerticalAlignment="VerticalEdge.Top"
                       Orientation="Orientation.Horizontal" />

       @*  <DxChartArgumentAxis ArgumentType="ChartAxisDataType.Auto">
            <DxChartAxisTitle Text="@xAxisLabel" />
            <DxChartConstantLine Value="@LSL" Color="Color.Red" Width="2">
                <DxChartConstantLineLabel Text="@($"LSL={LSL:F3}")" />
            </DxChartConstantLine>
            <DxChartConstantLine Value="@USL" Color="Color.Red" Width="2">
                <DxChartConstantLineLabel Text="@($"USL={USL:F3}")" />
            </DxChartConstantLine>
            <DxChartConstantLine Value="@avg" Color="Color.Black" Width="2">
                <DxChartConstantLineLabel Text="@($"Avg={avg:F3}")" />
            </DxChartConstantLine>
            <DxChartConstantLine Value="@UCL" Color="Color.Blue" Width="1">
                <DxChartConstantLineLabel Text="@($"UCL={UCL:F3}")" />
            </DxChartConstantLine>
            <DxChartConstantLine Value="@LCL" Color="Color.Blue" Width="1">
                <DxChartConstantLineLabel Text="@($"LCL={LCL:F3}")" />
            </DxChartConstantLine>
        </DxChartArgumentAxis> *@

        @if (limitAxis == "X-Axis")
        {
            <DxChartArgumentAxis ArgumentType="ChartAxisDataType.Auto">
                <DxChartAxisTitle Text="@xAxisLabel" />
                <DxChartConstantLine Value="@LSL" Color="Color.Red" Width="2">
                    <DxChartConstantLineLabel Text="@($"LSL={LSL:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@USL" Color="Color.Red" Width="2">
                    <DxChartConstantLineLabel Text="@($"USL={USL:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@avg" Color="Color.Black" Width="2">
                    <DxChartConstantLineLabel Text="@($"Avg={avg:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@UCL" Color="Color.Blue" Width="1">
                    <DxChartConstantLineLabel Text="@($"UCL={UCL:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@LCL" Color="Color.Blue" Width="1">
                    <DxChartConstantLineLabel Text="@($"LCL={LCL:F3}")" />
                </DxChartConstantLine>
            </DxChartArgumentAxis>
        }
        else if (limitAxis == "Y-Axis")
        {
            <DxChartValueAxis>
                <DxChartAxisTitle Text="@yAxisLabel" />
                <DxChartConstantLine Value="@LSL" Color="Color.Red" Width="2">
                    <DxChartConstantLineLabel Text="@($"LSL={LSL:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@USL" Color="Color.Red" Width="2">
                    <DxChartConstantLineLabel Text="@($"USL={USL:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@avg" Color="Color.Black" Width="2">
                    <DxChartConstantLineLabel Text="@($"Avg={avg:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@UCL" Color="Color.Blue" Width="1">
                    <DxChartConstantLineLabel Text="@($"UCL={UCL:F3}")" />
                </DxChartConstantLine>
                <DxChartConstantLine Value="@LCL" Color="Color.Blue" Width="1">
                    <DxChartConstantLineLabel Text="@($"LCL={LCL:F3}")" />
                </DxChartConstantLine>
            </DxChartValueAxis>
        }

        <DxChartZoomAndPanSettings ArgumentAxisZoomAndPanMode="ChartAxisZoomAndPanMode.Both" />
        <DxChartScrollBarSettings ArgumentAxisScrollBarVisible="true"
                                  ArgumentAxisScrollBarPosition="ChartScrollBarPosition.Bottom" />
        <!-- Histogram -->
        <DxChartBarSeries T="CapabilityData"
                          TArgument="string"
                          TValue="int"
                          Name="Frequency"
                          ArgumentField="c => c.XLabel"
                          ValueField="c => c.Frequency" />

        <!-- Line -->
        <DxChartLineSeries T="CapabilityData"
                           TArgument="string"
                           TValue="double"
                           Name="Normal Curve"
                           ArgumentField="c => c.XLabel"
                           ValueField="c => c.NormalizedCurve"
                           Color="Color.Orange" />

        <!-- Spline -->
        <DxChartSplineSeries T="CapabilityData"
                             TArgument="string"
                             TValue="double"
                             Name="Spline Raw"
                             ArgumentField="c => c.XLabel"
                             ValueField="c => c.OriginalValue"
                             Color="Color.Blue" />

        <!-- Scatter -->
        @foreach (var group in coloredScatterGroups)
        {
            <DxChartScatterSeries T="CapabilityData"
                                  Data="@group.Value"
                                  TArgument="string"
                                  TValue="double"
                                  Name="@group.Key"
                                  ArgumentField="d => d.XLabel"
                                  ValueField="d => d.OriginalValue"
                                  Color="@GetColorFromName(group.Key)" />
        }
        ChartAxisDataType


    </DxChart>

}

@code {

    bool isOpen = false;

    void ToggleAccordion()
    {
        isOpen = !isOpen;
    }
    bool isPopupVisible;

    List<string> tableList = new();
    List<string> columnList = new();
    List<string> numericColumnList = new();

    List<dynamic> tableRawData = new();
    List<dynamic> selectedRawData = new();
    List<string> dynamicColumns = new();

    string selectedTable, xField, yField;
    string chartTitle = "SPC Capability Chart";
    string xAxisLabel = "X Axis", yAxisLabel = "Y Axis";

    double avg, UCL, LCL;
    double Sig1 = 0, Sig2 = 0, Sig3 = 0;
    double LSL = 99.76;
    double USL = 100.025;
    List<CapabilityData> processedData = new();

    string limitAxis = "Y-Axis"; // default
    List<string> limitAxisOptions = new() { "X-Axis", "Y-Axis" };


    string dateField;
    List<string> dateColumnList = new();
    DateTime? startDate = DateTime.Today;
    DateTime? endDate = DateTime.Today.AddDays(7);
    DateTime? minDate;
    DateTime? maxDate;
    List<(double X, double Y, DateTime Date, string XLabel, string YLabel)> selectedPointsWithDates = new();


    public class CapabilityData
    {
        public double SpecificGravity { get; set; }  // X Axis
        public int Frequency { get; set; }           // Histogram (Bar)
        public double NormalizedCurve { get; set; }  // Normal Curve (Line)
        public double OriginalValue { get; set; }    // Raw Y value for Scatter/Spline
        public string PointColor { get; set; }       // For conditional coloring


        public string XLabel { get; set; }      // <-- String X Axis       
    }


    protected override async Task OnInitializedAsync()
    {
        tableList = await chartService.GetTableListAsync();
    }

    private async Task OnTableChanged(string table)
    {
        selectedTable = table;

        // Load columns for combo
        columnList = await chartService.GetColumnListAsync(table);

        // Filter numeric columns for selection
        numericColumnList = await chartService.GetNumericColumnsAsync(table);

        // Dates: any column with type Date/DateTime
        dateColumnList = await chartService.GetColumnListAsync(table);

        // Load entire raw data for popup selection
        tableRawData = await chartService.GetDynamicRawTableDataAsync(table);

        // Also prepare DxGrid column list
        dynamicColumns = columnList;
    }
    List<(double X, double Y, DateTime Date, string XLabel, string YLabel)> ConvertRawDataToPoints()
    {
        var result = new List<(double, double, DateTime, string, string)>();

        if (string.IsNullOrEmpty(xField) || string.IsNullOrEmpty(yField) || string.IsNullOrEmpty(dateField))
            return result;

        foreach (var row in tableRawData)
        {
            var dict = (IDictionary<string, object>)row;

            // Ensure all required fields exist
            if (!dict.ContainsKey(xField) || !dict.ContainsKey(yField) || !dict.ContainsKey(dateField))
                continue;

            var xObj = dict[xField];
            var yObj = dict[yField];
            var dateObj = dict[dateField];

            // Skip if X or Y is null or empty
            if (xObj == null || yObj == null || string.IsNullOrWhiteSpace(xObj.ToString()) || string.IsNullOrWhiteSpace(yObj.ToString()))
                continue;

            // Parse date
            if (!DateTime.TryParse(dateObj?.ToString(), out var dateVal))
                continue;

            // Convert to numeric (for chart plotting)
            double xNum = GetNumericValue(xObj.ToString());
            double yNum = GetNumericValue(yObj.ToString());

            result.Add((xNum, yNum, dateVal, xObj.ToString(), yObj.ToString()));
        }

        return result;
    }
    private Dictionary<string, int> stringValueMap = new();

    private double GetNumericValue(string value)
    {
        if (double.TryParse(value, out var num))
            return num;

        if (!stringValueMap.ContainsKey(value))
            stringValueMap[value] = stringValueMap.Count + 1;

        return stringValueMap[value];
    }

    private void CheckAxesSelected()
    {
        var dataPoints = ConvertRawDataToPoints();
        if (!dataPoints.Any())
            return;

        // compute data bounds
        minDate = dataPoints.Min(p => p.Date);
        maxDate = dataPoints.Max(p => p.Date);

        // Determine default end:
        // - Prefer Today when it's inside the data range (so user sees "up to today")
        // - Otherwise use the latest data point (maxDate)
        DateTime defaultEnd = (minDate.Value <= DateTime.Today && DateTime.Today <= maxDate.Value)
                              ? DateTime.Today
                              : maxDate.Value;

        // Default start = 7 days before defaultEnd, clamped to minDate
        DateTime defaultStart = defaultEnd.AddDays(-7);
        if (defaultStart < minDate.Value) defaultStart = minDate.Value;

        // Safety: ensure start <= end (fallback to full range start if something odd)
        if (defaultStart > defaultEnd) defaultStart = minDate.Value;

        startDate = defaultStart;
        endDate = defaultEnd;

        // Sort and cache points
        selectedPointsWithDates = dataPoints.OrderBy(p => p.Date).ToList();

        // Load chart with the window (if empty, fall back to whole range)
        var window = selectedPointsWithDates.Where(p => p.Date >= startDate && p.Date <= endDate).ToList();
        LoadChart(window.Any() ? window : selectedPointsWithDates);
    }

    private void ApplyDateFilter()
    {
        if (!startDate.HasValue || !endDate.HasValue) return;

        DateTime s = startDate.Value;
        DateTime e = endDate.Value;

        // Clamp to actual data range if available
        if (minDate.HasValue && s < minDate.Value) s = minDate.Value;
        if (maxDate.HasValue && e > maxDate.Value) e = maxDate.Value;

        // If user accidentally swapped them, swap back
        if (s > e)
        {
            var tmp = s;
            s = e;
            e = tmp;
        }

        // Persist any corrected values back to the bound properties
        startDate = s;
        endDate = e;

        var filtered = selectedPointsWithDates.Where(p => p.Date >= s && p.Date <= e).ToList();
        LoadChart(filtered);
    }


    private void CheckAxesSelected_()
    {
        var dataPoints = ConvertRawDataToPoints();

        if (dataPoints.Any())
        {
            minDate = dataPoints.Min(p => p.Date);
            maxDate = dataPoints.Max(p => p.Date);
            startDate = DateTime.Today;
            endDate = DateTime.Today.AddDays(7) > maxDate ? maxDate : DateTime.Today.AddDays(7);

            selectedPointsWithDates = dataPoints;

            LoadChart(dataPoints);

        }
    }
    private void ApplyDateFilter_()
    {
        if (startDate == null || endDate == null) return;

        var filtered = selectedPointsWithDates
    .Where(p => p.Date >= startDate && p.Date <= endDate)
    .ToList();
        LoadChart(filtered);

    }

    private void OnSelectedDataItemsChanged(IEnumerable<object> selected)
    {
        selectedRawData = selected.Cast<dynamic>().ToList();
    }

    private void OnConfirmSelection()
    {
        isPopupVisible = false;
        if (!selectedRawData.Any()) return;

        var selectedPoints = selectedRawData.Select(row =>
        {
            var dict = (IDictionary<string, object>)row;
            double xVal = Convert.ToDouble(dict[xField]);
            double yVal = Convert.ToDouble(dict[yField]);

            // try to parse date if column exists
            DateTime dateVal = DateTime.TryParse(dict[dateField]?.ToString(), out var d)
                ? d
                : DateTime.MinValue;

            return (xVal, yVal, dateVal, dict[xField]?.ToString(), dict[yField]?.ToString());
        }).ToList();

        LoadChart(selectedPoints);
    }


    private void LoadChart(List<(double X, double Y, DateTime Date, string XLabel, string YLabel)> selectedPoints)
    {
        var yValues = selectedPoints.Select(d => d.Y).ToList();

        avg = yValues.Average();
        var n = yValues.Count;
        var variance = yValues.Sum(v => Math.Pow(v - avg, 2)) / (n - 1);
        var sigma = Math.Sqrt(variance);
        UCL = avg + 3 * sigma;
        LCL = avg - 3 * sigma;

        // Histogram (rounded bins)
        var grouped = yValues.GroupBy(v => Math.Round(v, 3))
                             .ToDictionary(g => g.Key, g => g.Count());

        var pdfValues = grouped.Keys.Select(k =>
            (SG: k,
             PDF: (1.0 / (sigma * Math.Sqrt(2 * Math.PI))) *
                  Math.Exp(-0.5 * Math.Pow((k - avg) / sigma, 2))
            )).ToList();

        var maxFreq = grouped.Max(g => g.Value);
        var maxPdf = pdfValues.Max(p => p.PDF);
        var scaleFactor = maxFreq / maxPdf;

        processedData = selectedPoints.Select(p => new CapabilityData
        {
            XLabel = p.XLabel,   // ✅ now available
            Frequency = grouped.ContainsKey(Math.Round(p.Y, 3)) ? grouped[Math.Round(p.Y, 3)] : 1,
            NormalizedCurve = pdfValues.First(v => Math.Abs(v.SG - Math.Round(p.Y, 3)) < 0.0001).PDF * scaleFactor,
            OriginalValue = p.Y,
            PointColor = p.Y < LSL ? "Red" : p.Y > USL ? "Orange" : "Green"
        }).OrderBy(d => d.XLabel).ToList();

        coloredScatterGroups = processedData
            .GroupBy(d => d.PointColor)
            .ToDictionary(g => g.Key, g => g.ToList());
    }

    void Grid_CustomizeElement(GridCustomizeElementEventArgs e)
    {
        if (e.ElementType == GridElementType.DataRow && e.VisibleIndex % 2 == 1)
        {
            e.CssClass = "alt-item";
        }
        if (e.ElementType == GridElementType.HeaderCell)
        {
            e.Style = "background-color: #E6E6E6;";
            e.CssClass = "header-bold";
        }
    }
    Dictionary<string, List<CapabilityData>> coloredScatterGroups = new();

    Color GetColorFromName(string colorName)
    {
        return colorName.ToLower() switch
        {
            "red" => Color.Red,
            "green" => Color.Green,
            "orange" => Color.Orange,
            "blue" => Color.Blue,
            "yellow" => Color.Yellow,
            _ => Color.Gray
        };
    }

}
