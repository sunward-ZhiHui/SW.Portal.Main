@using System.Globalization
@using System.Drawing
@using DevExpress.Blazor
@inject ChartService chartService

<style scoped>
    .accordion {
        border: 1px solid #ccc;
        border-radius: 8px;
        margin: 10px 0;
        overflow: hidden;
    }

    .accordion-header {
        padding: 12px;
        font-weight: bold;
        cursor: pointer;
        background: #f1f1f1;
        transition: background 0.3s;
    }

        .accordion-header:hover {
            background: #e5e5e5;
        }

    .accordion-content {
        padding: 12px;
        background: #fafafa;
        border-top: 1px solid #ccc;
        animation: fadeIn 0.3s ease-in-out;
    }
</style>
<div class="accordion">
    <div class="accordion-header" @onclick="ToggleAccordion">
        <span>@(isOpen ? "▼ " : "► ") Trending Chart </span> 
    </div>

    @if (isOpen)
    {
        <div style="padding:10px;">
            <div class="row mb-2 mt-4">
                <div class="col-md-4">
                    <label>Select Table</label>
                    <DxComboBox T="string"
                                SearchMode="ListSearchMode.AutoSearch"
                                SearchFilterCondition="ListSearchFilterCondition.Contains"
                                Data="@tableList"
                                Value="@selectedTable"
                                ValueChanged="@((string? newValue) => OnTableChanged(newValue))"
                                NullText="Select Table" />
                </div>
                <div class="col-md-8">
                    @if (columnList?.Count > 0)
                    {
                        <div class="row">
                            <div class="col-md-4">
                                <label> Select X Axis </label>
                                <DxComboBox T="string"
                                            SearchMode="ListSearchMode.AutoSearch"
                                            SearchFilterCondition="ListSearchFilterCondition.Contains"
                                            Data="@columnList"
                                            Value="@xField"
                                            ValueChanged="@((string? newValue) => { xField = newValue; CheckAxesSelected(); })"
                                            NullText="Select X-Axis" />
                            </div>
                            <div class="col-md-4">
                                <label>Select Y Axis</label>
                                <DxComboBox T="string"
                                            SearchMode="ListSearchMode.AutoSearch"
                                            SearchFilterCondition="ListSearchFilterCondition.Contains"
                                            Data="@columnList"
                                            Value="@yField"
                                            ValueChanged="@((string? newValue) => { yField = newValue; CheckAxesSelected(); })"
                                            NullText="Select Y-Axis" />
                            </div>
                            <div class="col-md-4">
                                <label>Select Date Column</label>
                                <DxComboBox T="string"
                                            SearchMode="ListSearchMode.AutoSearch"
                                            SearchFilterCondition="ListSearchFilterCondition.Contains"
                                            Data="@dateColumnList"
                                            Value="@dateField"
                                            ValueChanged="@((string? newValue) => { dateField = newValue; CheckAxesSelected(); })"
                                            NullText="Select Date Column" />
                            </div>
                        </div>
                    }
                </div>

            </div>
            <div class="row mb-2 mt-4">
                <div class="col-md-8">
                    <div class="row">
                        <div class="col-md-3">
                            <label>LSL Value</label>
                            <DxSpinEdit @bind-Value="LSL" NullText="LSL" />
                        </div>
                        <div class="col-md-3">
                            <label>USL Value</label>
                            <DxSpinEdit @bind-Value="USL" NullText="USL" />
                        </div>
                        <div class="col-md-3">
                            <label>UCL Value</label>
                            <DxSpinEdit @bind-Value="UCL" NullText="UCL" />
                        </div>
                        <div class="col-md-3">
                        <label>LCL Value</label>
                        <DxSpinEdit @bind-Value="LCL" NullText="LCL" />
                    </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="row">
                        <div class="col-md-4">
                            <label>Sigma 1</label>
                            <DxSpinEdit @bind-Value="Sig1" NullText="Sigma -1" />
                        </div>

                        <div class="col-md-4">
                            <label>Sigma 2</label>
                            <DxSpinEdit @bind-Value="Sig2" NullText="Sigma -2" />
                        </div>

                        <div class="col-md-4">
                            <label>Sigma 3</label>
                            <DxSpinEdit @bind-Value="Sig3" NullText="Sigma -3" />
                        </div>
                    </div>                    
                </div>
            </div>
            <div class="row mb-2 mt-4">

                @* <div class="col-md-4">
                <div class="row">
                    <div class="col-md-6">
                        <label>LSL Value</label>
                        <DxSpinEdit @bind-Value="LSL" NullText="LSL" />
                    </div>
                    <div class="col-md-6">
                        <label>USL Value</label>
                        <DxSpinEdit @bind-Value="USL" NullText="USL" />
                    </div>
                </div>

            </div> *@
                <div class="col-md-12">
                    <div class="row">
                        <div class="col-md-4">
                            <label>Chart Title</label>
                            <DxTextBox @bind-Text="chartTitle" NullText="Chart Title" />
                        </div>
                        <div class="col-md-4">
                            <label>X Axis</label>
                            <DxTextBox @bind-Text="xAxisLabel" NullText="X Axis Label" />
                        </div>
                        <div class="col-md-4">
                            <label>Y Axis</label>
                            <DxTextBox @bind-Text="yAxisLabel" NullText="Y Axis Label" />
                        </div>
                    </div>
                </div>

            </div>
            <div class="row mb-2 mt-4">
                <div class="col-md-2">
                    <label>Start Date:</label>
                    <DxDateEdit @bind-Date="StartDate"
                                MinDate="@StartPickerMin"
                                MaxDate="@StartPickerMax" />

                </div>
                <div class="col-md-2">
                    <label>End Date:</label>
                    <DxDateEdit @bind-Date="EndDate"
                                MinDate="@EndPickerMin"
                                MaxDate="@EndPickerMax" />
                </div>
                <div class="col-md-3 align-self-end">
                    <DxButton Text="Apply Date Filter" Click="ApplyDateFilter" />
                </div>
            </div>
        </div>       

    }
</div>



@* <h4>Conditional Formatting Rules</h4> *@
@foreach (var rule in Rules)
{
    <div class="mb-2 d-flex align-items-center">
        <label class="me-2">Min:</label>
        <InputNumber @bind-Value="rule.Min" class="form-control me-2" />

        <label class="me-2">Max:</label>
        <InputNumber @bind-Value="rule.Max" class="form-control me-2" />

        <label class="me-2">Operator:</label>
        <select @bind="rule.Operator" class="form-select me-2">
            @foreach (ComparisonOperator op in Enum.GetValues(typeof(ComparisonOperator)))
            {
                <option value="@op">@GetOperatorSymbol(op)</option>
            }
        </select>

        <label class="me-2">Color:</label>
        <input type="color" @bind="rule.ColorHex" class="form-control-color me-2" />

        <button class="btn btn-danger btn-sm" @onclick="@(() => RemoveRule(rule))">✕</button>
    </div>
}

<button class="btn btn-sm btn-primary mt-2" @onclick="AddRule">Add Rule</button>

@* <button class="btn btn-success mt-3" @onclick="GenerateChart">Generate Chart</button> *@

<DxChart T="CapabilityData" Width="100%" Height="500px">
    <DxChartTitle Text="@($"{chartTitle} | Avg={avg:F3}, UCL={UCL:F3}, LCL={LCL:F3}")" />
     <DxChartLegend Orientation="Orientation.Vertical"
                   HorizontalAlignment="HorizontalAlignment.Right"
                   Position="RelativePosition.Outside" Visible="false">
                   </DxChartLegend>
    <DxChartArgumentAxis ArgumentType="ChartAxisDataType.Auto" />
    <DxChartValueAxis>
        <DxChartConstantLine Value="@LSL" Color="Color.Red" Width="3" DashStyle="ChartDashStyle.Dash">
            <DxChartConstantLineLabel Text="@($"LSL={LSL:F3}")" />
        </DxChartConstantLine>
        <DxChartConstantLine Value="@USL" Color="Color.Red" Width="3" DashStyle="ChartDashStyle.Dash">
            <DxChartConstantLineLabel Text="@($"USL={USL:F3}")" />
        </DxChartConstantLine>
        <DxChartConstantLine Value="@avg" Color="Color.Black" Width="2">
            <DxChartConstantLineLabel Text="@($"Avg={avg:F3}")" />
        </DxChartConstantLine>
        <DxChartConstantLine Value="@UCL" Color="Color.Blue" Width="3" DashStyle="ChartDashStyle.Dot">
            <DxChartConstantLineLabel Text="@($"UCL={UCL:F3}")" />
        </DxChartConstantLine>
        <DxChartConstantLine Value="@LCL" Color="Color.Blue" Width="3" DashStyle="ChartDashStyle.Dot">
            <DxChartConstantLineLabel Text="@($"LCL={LCL:F3}")" />
        </DxChartConstantLine>
    </DxChartValueAxis>


    @foreach (var segment in SegmentedData)
    {
        <DxChartSplineSeries T="CapabilityData"
                             TArgument="string"
                             TValue="double"
                             Data="@segment.Points"
                             ArgumentField="p => p.XLabel"
                             ValueField="p => p.Value"
                             Color="@System.Drawing.ColorTranslator.FromHtml(segment.ColorHex)">
            <DxChartSeriesLabel Visible="true" />
        </DxChartSplineSeries>
    }



  @*   <!-- Main continuous line (always black) -->
    <DxChartSplineSeries T="CapabilityData"
                         TArgument="string"
                         TValue="double"
                         Data="@selectedChartData"
                         ArgumentField="p => p.XLabel"
                         ValueField="p => p.Value"
                         Color="Color.Black">
        <DxChartSeriesLabel Visible="true" /> 
    </DxChartSplineSeries>

    <!-- Overlay points with conditional colors -->
    @foreach (var point in selectedChartData)
    {
        <DxChartScatterSeries T="CapabilityData"
                              TArgument="string"
                              TValue="double"
                              Data="new List<CapabilityData> { point }"
                              ArgumentField="p => p.XLabel"
                              ValueField="p => p.Value"
                              Color="@System.Drawing.ColorTranslator.FromHtml(point.PointColorHex)">
            <DxChartSeriesPoint Size="8" />
        </DxChartScatterSeries>
    } *@

@* 
    @foreach (var group in selectedChartData.GroupBy(d => d.PointColorHex))
    {
        <DxChartSplineSeries T="CapabilityData"
                             TArgument="string"
                             TValue="double"
                             Data="@group.ToList()"
                             ArgumentField="p => p.XLabel"
                             ValueField="p => p.Value"
                             Color="@System.Drawing.ColorTranslator.FromHtml(group.Key)"
                             Name="@($"Range {group.Key}")">
            <DxChartSeriesLabel Visible="true" />
        </DxChartSplineSeries>
    } *@


    @if (colorGroups.Count == 0)
    {
       @*  <DxChartSplineSeries T="CapabilityData"
                             TArgument="string"
                             TValue="double"
                             Name="SPC Data"
                             Data="@selectedChartData"
                             ArgumentField="p => p.XLabel"
                             ValueField="p => p.Value"
                             >
           
            <DxChartSeriesLabel Visible="true" />
        </DxChartSplineSeries> *@


    }
    else
    {

       @*  @foreach (var group in selectedChartData.GroupBy(d => d.PointColorHex))
        {
            <DxChartSplineSeries T="CapabilityData"
                                 TArgument="string"
                                 TValue="double"
                                 Data="@group.ToList()"
                                 ArgumentField="p => p.XLabel"
                                 ValueField="p => p.Value"
                                 Color="@System.Drawing.ColorTranslator.FromHtml(group.Key)">
                <DxChartSeriesLabel Visible="false" />
            </DxChartSplineSeries>
        }
 *@


       @*  @foreach (var segment in SegmentedData)
        {
            <DxChartSplineSeries T="CapabilityData"
                                 TArgument="string"
                                 TValue="double"
                                 Data="@segment.Data"                                 
                                 ArgumentField="p => p.XLabel"
                                 ValueField="p => p.Value"
                                 Color="@System.Drawing.ColorTranslator.FromHtml(segment.Color)">
                <DxChartSeriesLabel Visible="false" />
            </DxChartSplineSeries>
        } *@

    }
</DxChart>



@code {


    // backing + property pair to run validation on set
    private bool _updatingDates;
    private DateTime? _startDate;
    public DateTime? StartDate
    {
        get => _startDate;
        set
        {
            if (_startDate == value) return;
            _startDate = value;
            if (!_updatingDates)
            {
                _updatingDates = true;
                EnsureDateRangeValid();
                _updatingDates = false;
                StateHasChanged();
            }
        }
    }

    private DateTime? _endDate;
    public DateTime? EndDate
    {
        get => _endDate;
        set
        {
            if (_endDate == value) return;
            _endDate = value;
            if (!_updatingDates)
            {
                _updatingDates = true;
                EnsureDateRangeValid();
                _updatingDates = false;
                StateHasChanged();
            }
        }
    }

    // computed non-nullable picker bounds
    private DateTime StartPickerMin => minDate ?? DateTime.Today.AddYears(-10);
    private DateTime StartPickerMax => EndDate ?? maxDate ?? DateTime.Today.AddYears(10);

    private DateTime EndPickerMin => StartDate ?? minDate ?? DateTime.Today.AddYears(-10);
    private DateTime EndPickerMax => maxDate ?? DateTime.Today.AddYears(10);



    bool isOpen = false;

    void ToggleAccordion()
    {
        isOpen = !isOpen;
    }

    bool isPopupVisible;

    List<string> axisOptions = new() { "X-Axis", "Y-Axis" };


    List<string> tableList = new();
    List<string> columnList = new();
    List<string> numericColumnList = new();

    List<dynamic> tableRawData = new();
    List<dynamic> selectedRawData = new();
    List<string> dynamicColumns = new();

    string selectedTable, xField, yField;
    string chartTitle = "SPC Capability Chart";
    string xAxisLabel = "X Axis", yAxisLabel = "Y Axis";

    double avg, UCL, LCL, LSL, USL;
    double Sig1 = 0, Sig2 = 0, Sig3 = 0;
    string specLimitAxis = "Y-Axis"; // Default
    List<CapabilityData> processedData = new();



    string dateField;
    List<string> dateColumnList = new();
    DateTime? startDate = DateTime.Today;
    DateTime? endDate = DateTime.Today.AddDays(7);
    DateTime? minDate;
    DateTime? maxDate;
    List<(double X, double Y, DateTime Date, string XLabel, string YLabel)> selectedPointsWithDates = new();

    private void OnStartDateChanged(DateTime? newDate)
    {
        startDate = newDate;
        EnsureDateRangeValid();
    }

    private void OnEndDateChanged(DateTime? newDate)
    {
        endDate = newDate;
        EnsureDateRangeValid();
    }




    public class ChartSegment
    {
        public List<CapabilityData> Data { get; set; } = new();
        public string Color { get; set; }   // changed from string → Color
        public string ColorHex { get; set; }
        public List<CapabilityData> Points { get; set; } = new();
    }


    public List<ChartSegment> SegmentedData { get; set; } = new();
    List<CapabilityData> allData;      // full data (never touched)

    public class CapabilityData
    {
        public string XLabel { get; set; }    // <-- String X axis label
        public double SpecificGravity { get; set; } // Keep numeric if needed for calc
        public int Frequency { get; set; }
        public double NormalizedCurve { get; set; }
        public double Value { get; set; }     // Y-Axis
        public Color PointColor { get; set; }
        public string PointColorHex { get; set; } = "#000000";
    }
    private void BuildSegments(List<CapabilityData> allPoints)
    {
        SegmentedData.Clear();

        if (allPoints.Count == 0)
            return;

        string currentColor = allPoints[0].PointColorHex ?? "#000000";
        var currentSegment = new ChartSegment { ColorHex = currentColor };
        currentSegment.Points.Add(allPoints[0]);

        for (int i = 1; i < allPoints.Count; i++)
        {
            var pt = allPoints[i];
            var color = pt.PointColorHex ?? "#000000";

            if (color != currentColor)
            {
                // duplicate boundary point for continuity
                currentSegment.Points.Add(pt);

                SegmentedData.Add(currentSegment);

                // start new segment
                currentColor = color;
                currentSegment = new ChartSegment { ColorHex = color };
                currentSegment.Points.Add(pt);
            }
            else
            {
                currentSegment.Points.Add(pt);
            }
        }

        SegmentedData.Add(currentSegment);
    }

    public class ScatterSeriesGroup
    {
        public string SeriesName { get; set; }
        public Color SeriesColor { get; set; }
        public List<CapabilityData> Data { get; set; } = new();
    }

    public enum ComparisonOperator
    {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
        Between // Special case for Min-Max range
    }

    public class ConditionalFormatRule
    {
        public double Min { get; set; }
        public double Max { get; set; }
        public string ColorHex { get; set; } = "#000000";
        public ComparisonOperator Operator { get; set; } = ComparisonOperator.Between;
    }

    private List<ConditionalFormatRule> Rules = new();

    private void AddRule()
    {
        Rules.Add(new ConditionalFormatRule());
    }

    private void RemoveRule(ConditionalFormatRule rule)
    {
        Rules.Remove(rule);
    }

    private string GetOperatorSymbol(ComparisonOperator op) => op switch
    {
        ComparisonOperator.GreaterThan => ">",
        ComparisonOperator.GreaterThanOrEqual => ">=",
        ComparisonOperator.LessThan => "<",
        ComparisonOperator.LessThanOrEqual => "<=",
        ComparisonOperator.Equal => "=",
        ComparisonOperator.Between => "Between",
        _ => "?"
    };


    // private List<ConditionalFormatRule> Rules = new()
    // {
    //     new ConditionalFormatRule { Min = 0.0, Max = 1.1, ColorHex = "#FF0000" },
    //     new ConditionalFormatRule { Min = 1.1, Max = 1.3, ColorHex = "#FFA500" },
    //     new ConditionalFormatRule { Min = 1.3, Max = 2.0, ColorHex = "#00FF00" }
    // };

    // private void AddRule() => Rules.Add(new ConditionalFormatRule());


    private List<ScatterSeriesGroup> scatterColorSeries = new(); // Final grouped result
    private List<CapabilityData> selectedChartData = new();



    protected override async Task OnInitializedAsync()
    {
        tableList = await chartService.GetTableListAsync();
    }

    private async Task OnTableChanged(string table)
    {
        selectedTable = table;

        // Load columns for combo
        columnList = await chartService.GetColumnListAsync(table);

        // Filter numeric columns for selection
        numericColumnList = await chartService.GetNumericColumnsAsync(table);

        // Dates: any column with type Date/DateTime
        dateColumnList = await chartService.GetColumnListAsync(table);

        // Load entire raw data for popup selection
        tableRawData = await chartService.GetDynamicRawTableDataAsync(table);

        // Also prepare DxGrid column list
        dynamicColumns = columnList;
    }
    List<(double X, double Y, DateTime Date, string XLabel, string YLabel)> ConvertRawDataToPoints()
    {
        var result = new List<(double, double, DateTime, string, string)>();

        if (string.IsNullOrEmpty(xField) || string.IsNullOrEmpty(yField) || string.IsNullOrEmpty(dateField))
            return result;

        foreach (var row in tableRawData)
        {
            var dict = (IDictionary<string, object>)row;

            // Ensure all required fields exist
            if (!dict.ContainsKey(xField) || !dict.ContainsKey(yField) || !dict.ContainsKey(dateField))
                continue;

            var xObj = dict[xField];
            var yObj = dict[yField];
            var dateObj = dict[dateField];

            // Skip if X or Y is null or empty
            if (xObj == null || yObj == null || string.IsNullOrWhiteSpace(xObj.ToString()) || string.IsNullOrWhiteSpace(yObj.ToString()))
                continue;

            // Parse date
            if (!DateTime.TryParse(dateObj?.ToString(), out var dateVal))
                continue;

            // Convert to numeric (for chart plotting)
            double xNum = GetNumericValue(xObj.ToString());
            double yNum = GetNumericValue(yObj.ToString());

            result.Add((xNum, yNum, dateVal, xObj.ToString(), yObj.ToString()));

        }

        return result;
    }
    private Dictionary<string, int> stringValueMap = new();

    private double GetNumericValue(string value)
    {
        if (double.TryParse(value, out var num))
            return num;

        if (!stringValueMap.ContainsKey(value))
            stringValueMap[value] = stringValueMap.Count + 1;

        return stringValueMap[value];
    }

    private void CheckAxesSelected()
    {
        var dataPoints = ConvertRawDataToPoints();

        if (!dataPoints.Any())
            return;

        minDate = dataPoints.Min(p => p.Date);
        maxDate = dataPoints.Max(p => p.Date);

        // sensible defaults: start = minDate, end = min(minDate + 7, maxDate)
        startDate = minDate;
        endDate = minDate.Value.AddDays(7) <= maxDate.Value ? minDate.Value.AddDays(7) : maxDate;

        // ensure invariants
        EnsureDateRangeValid();

        selectedPointsWithDates = dataPoints;

        // load chart using the initial window
        var initialWindow = dataPoints
            .Where(p => (!startDate.HasValue || p.Date >= startDate.Value)
                     && (!endDate.HasValue || p.Date <= endDate.Value))
            .ToList();

        LoadChartWithLabels(initialWindow);
    }
    private void EnsureDateRangeValid()
    {
        // clamp to dataset bounds
        if (minDate.HasValue && StartDate.HasValue && StartDate.Value < minDate.Value)
            StartDate = minDate;
        if (maxDate.HasValue && EndDate.HasValue && EndDate.Value > maxDate.Value)
            EndDate = maxDate;

        // if both present and start > end, fix by keeping start and setting end = start
        if (StartDate.HasValue && EndDate.HasValue && StartDate.Value > EndDate.Value)
        {
            EndDate = StartDate;
        }

        // default nulls to dataset bounds (optional)
        if (!StartDate.HasValue && minDate.HasValue) StartDate = minDate;
        if (!EndDate.HasValue && maxDate.HasValue) EndDate = maxDate;
    }
    private void EnsureDateRangeValid_v()
    {
        // clamp to dataset bounds if available
        if (minDate.HasValue && startDate.HasValue && startDate.Value < minDate.Value)
            startDate = minDate;

        if (maxDate.HasValue && endDate.HasValue && endDate.Value > maxDate.Value)
            endDate = maxDate;

        // if both present and end < start, fix by swapping (you can choose to set end = start instead)
        if (startDate.HasValue && endDate.HasValue && endDate.Value < startDate.Value)
        {
            // Option A: swap so start <= end
            var tmp = startDate;
            startDate = endDate;
            endDate = tmp;

            // Option B (alternative): set endDate = startDate
            // endDate = startDate;
        }

        // final safety clamp again (in case swap created out-of-bounds)
        if (minDate.HasValue && startDate.HasValue && startDate.Value < minDate.Value)
            startDate = minDate;
        if (maxDate.HasValue && endDate.HasValue && endDate.Value > maxDate.Value)
            endDate = maxDate;
    }
    private void ApplyDateFilter()
    {
        EnsureDateRangeValid();

        if (!StartDate.HasValue || !EndDate.HasValue)
            return;

        var filtered = selectedPointsWithDates
            .Where(p => p.Date.Date >= StartDate.Value.Date   // inclusive start
                     && p.Date.Date <= EndDate.Value.Date)    // inclusive end
            .ToList();

        LoadChartWithLabels(filtered);
    }

    private void CheckAxesSelected_()
    {
        var dataPoints = ConvertRawDataToPoints();

        if (dataPoints.Any())
        {
            minDate = dataPoints.Min(p => p.Date);
            maxDate = dataPoints.Max(p => p.Date);
            startDate = DateTime.Today;
            endDate = DateTime.Today.AddDays(7) > maxDate ? maxDate : DateTime.Today.AddDays(7);

            selectedPointsWithDates = dataPoints;

            LoadChart(dataPoints.Select(p => (p.X, p.Y)).ToList());
        }
    }


    private void ApplyDateFilter_()
    {
        if (startDate == null || endDate == null) return;


        var filtered = selectedPointsWithDates
            .Where(p => p.Date >= startDate && p.Date <= endDate)
            .ToList();

        LoadChartWithLabels(filtered);
       
    }

    private void LoadChartWithLabels__V(List<(double X, double Y, DateTime Date, string XLabel, string YLabel)> points)
    {
        if (points == null || points.Count == 0)
            return;

        selectedChartData = points
            .OrderBy(p => p.X) // Or keep .OrderBy(p => p.XLabel) for alphabetical
            .Select(p => new CapabilityData
            {
                XLabel = p.XLabel, // String for chart display
                SpecificGravity = p.X, // Keep numeric for stats
                Value = p.Y
            })
            .ToList();

        // Stats
        var yValues = selectedChartData.Select(d => d.Value).ToList();
        avg = yValues.Average();
        var n = yValues.Count;
        var variance = yValues.Sum(v => Math.Pow(v - avg, 2)) / (n - 1);
        var sigma = Math.Sqrt(variance);
        UCL = yValues.Max();
        LCL = yValues.Min();

        // Color rules
        colorGroups.Clear();
        if (Rules != null && Rules.Count > 0)
        {
            foreach (var rule in Rules)
            {
                string key = rule.ColorHex;
                if (!colorGroups.ContainsKey(key))
                    colorGroups[key] = new List<CapabilityData>();

                colorGroups[key].AddRange(selectedChartData.Where(p => MatchesRule(p.Value, rule)));
            }
        }

        // Build SegmentedData
        SegmentedData.Clear();

        if (colorGroups.Count == 0)
        {
            // No rules → one segment with all data
            SegmentedData.Add(new ChartSegment
            {
                Color = "#000000", // default black (or choose)
                Data = selectedChartData
            });
        }
        else
        {
            foreach (var kvp in colorGroups)
            {
                SegmentedData.Add(new ChartSegment
                {
                    Color = kvp.Key,        // hex from rule
                    Data = kvp.Value.OrderBy(p => p.XLabel).ToList()
                });
            }
        }


        StateHasChanged();
    }

    private void LoadChartWithLabels(List<(double X, double Y, DateTime Date, string XLabel, string YLabel)> points)
    {
        if (points == null || points.Count == 0)
            return;

        selectedChartData = points
            .OrderBy(p => p.XLabel)
            .Select(p =>
            {
                var data = new CapabilityData
                {
                    XLabel = p.XLabel,
                    SpecificGravity = p.X,
                    Value = p.Y
                };

                // 🎨 Apply rules → assign PointColorHex
                foreach (var rule in Rules)
                {
                    if (MatchesRule(data.Value, rule))
                    {
                        data.PointColorHex = rule.ColorHex;
                        break;
                    }
                }

                return data;
            })
            .ToList();

        // 📌 Build Segments for colored line rendering
        BuildSegments(selectedChartData);

        // Stats
        var yValues = selectedChartData.Select(d => d.Value).ToList();
        avg = yValues.Average();
        var n = yValues.Count;
        var variance = yValues.Sum(v => Math.Pow(v - avg, 2)) / (n - 1);
        var sigma = Math.Sqrt(variance);
        UCL = yValues.Max();
        LCL = yValues.Min();

        StateHasChanged();
    }

    private void OnSelectedDataItemsChanged(IEnumerable<object> selected)
    {
        selectedRawData = selected.Cast<dynamic>().ToList();
    }
    private List<(double X, double Y)> selectedPoints = new();

    private void OnConfirmSelection()
    {
        isPopupVisible = false;
        if (!selectedRawData.Any()) return;

        // Convert dynamic selection to numeric
        selectedPoints = selectedRawData.Select(row =>
        {
            var dict = (IDictionary<string, object>)row;
            double xVal = Convert.ToDouble(dict[xField]);
            double yVal = Convert.ToDouble(dict[yField]);
            return (xVal, yVal);
        }).ToList();


        LoadChart(selectedPoints);
    }
    private Color GetPointColor(double y)
    {
        if (y < LSL) return Color.Red;
        else if (y > USL) return Color.Red;
        else if (y >= LSL && y <= USL) return Color.Green;
        else return Color.Gray;
    }
    private (string Label, Color Color) GetColorCategory(double y)
    {
        if (y < LSL) return ("Below LSL", Color.Red);
        if (y > USL) return ("Above USL", Color.Orange);
        return ("Within Spec", Color.Green);
    }

    private Dictionary<string, List<CapabilityData>> colorGroups = new();

    private void ApplyConditionalRules(List<(double X, double Y)> selectedPoints)
    {
        colorGroups.Clear();

        var allPoints = selectedPoints
            .OrderBy(p => p.X)
            .Select(p => new CapabilityData { SpecificGravity = p.X, Value = p.Y })
            .ToList();

        foreach (var rule in Rules)
        {
            var key = rule.ColorHex;
            if (!colorGroups.ContainsKey(key))
                colorGroups[key] = new List<CapabilityData>();

            colorGroups[key].AddRange(allPoints.Where(p => p.Value >= rule.Min && p.Value <= rule.Max));
        }
    }
    private void GenerateChart()
    {
        // This should use your existing `selectedPoints` list — however you define it
        if (selectedPoints != null && selectedPoints.Any())
        {
            LoadChart(selectedPoints);
        }
    }

    private void LoadChart(List<(double X, double Y)> selectedPoints)
    {
        if (selectedPoints == null || selectedPoints.Count == 0)
            return;

        selectedChartData = selectedPointsWithDates
            .OrderBy(p => p.XLabel)
            .Select(p =>
            {
                var data = new CapabilityData
                {
                    XLabel = p.XLabel,
                    Value = p.Y
                };

                // 🎨 Apply rules to this point
                foreach (var rule in Rules)
                {
                    if (MatchesRule(data.Value, rule))
                    {
                        data.PointColorHex = rule.ColorHex;
                        break;
                    }
                }

                return data;
            })
            .ToList();

        var yValues = selectedChartData.Select(d => d.Value).ToList();
        avg = yValues.Average();
        UCL = yValues.Max();
        LCL = yValues.Min();

        StateHasChanged();
    }


    private void LoadChart_VK(List<(double X, double Y)> selectedPoints)
    {
        colorGroups.Clear();

        selectedChartData = selectedPoints
            .OrderByDescending(p => p.X)
            .Select(p => new CapabilityData { SpecificGravity = p.X, Value = p.Y })
            .ToList();

        // If no rules, don't create groups — fallback to default rendering
        if (Rules == null || Rules.Count == 0)
            return;

        foreach (var rule in Rules)
        {
            string key = rule.ColorHex;

            if (!colorGroups.ContainsKey(key))
                colorGroups[key] = new List<CapabilityData>();

            colorGroups[key].AddRange(selectedChartData
                .Where(p => MatchesRule(p.Value, rule)));
        }
    }



    private bool MatchesRule(double value, ConditionalFormatRule rule)
    {
        return rule.Operator switch
        {
            ComparisonOperator.GreaterThan => value > rule.Min,
            ComparisonOperator.GreaterThanOrEqual => value >= rule.Min,
            ComparisonOperator.LessThan => value < rule.Max,
            ComparisonOperator.LessThanOrEqual => value <= rule.Max,
            ComparisonOperator.Equal => Math.Abs(value - rule.Min) < 0.0001,
            ComparisonOperator.Between => value >= rule.Min && value <= rule.Max,
            _ => false
        };
    }





    private void LoadChart__V(List<(double X, double Y)> selectedPoints)
    {
        // selectedChartData = selectedPoints.Select(p => new CapabilityData
        // {
        //     SpecificGravity = p.X,
        //     Value = p.Y
        // }).ToList();


        // selectedChartData = selectedPoints.OrderBy(p => p.X)
        //     .Select(p => new CapabilityData
        //     {
        //         SpecificGravity = p.X,
        //         Value = p.Y
        //     }).ToList();



        colorGroups.Clear();

        var allPoints = selectedPoints
            .OrderBy(p => p.X)
            .Select(p => new CapabilityData { SpecificGravity = p.X, Value = p.Y })
            .ToList();

        foreach (var rule in Rules)
        {
            var key = rule.ColorHex;
            if (!colorGroups.ContainsKey(key))
                colorGroups[key] = new List<CapabilityData>();

            colorGroups[key].AddRange(allPoints.Where(p => p.Value >= rule.Min && p.Value <= rule.Max));
        }



    }


    private void LoadChart_v(List<(double X, double Y)> selectedPoints)
    {
        var yValues = selectedPoints.Select(d => d.Y).ToList();

        avg = yValues.Average();

        // Sample standard deviation (n-1)
        var n = yValues.Count;
        var variance = yValues.Sum(v => Math.Pow(v - avg, 2)) / (n - 1);
        var sigma = Math.Sqrt(variance);

        UCL = avg + 3 * sigma;
        LCL = avg - 3 * sigma;

        // Histogram bins
        processedData = yValues
            .GroupBy(v => Math.Round(v, 3))
            .Select(g => new CapabilityData
            {
                SpecificGravity = g.Key,
                Value = g.Count(),
                PointColor = GetPointColor(g.Count()),
                Frequency = g.Count()
            })
            .OrderBy(d => d.SpecificGravity)
            .ToList();

        // Normal distribution overlay
        var maxFreq = processedData.Max(p => p.Frequency);
        var pdfValues = processedData.Select(p =>
            (SG: p.SpecificGravity,
             PDF: (1.0 / (sigma * Math.Sqrt(2 * Math.PI))) *
                  Math.Exp(-0.5 * Math.Pow((p.SpecificGravity - avg) / sigma, 2))
            )).ToList();

        var maxPdf = pdfValues.Max(p => p.PDF);
        var scaleFactor = maxFreq / maxPdf;

        foreach (var item in processedData)
        {
            var pdf = pdfValues.First(v => Math.Abs(v.SG - item.SpecificGravity) < 0.0001).PDF;
            item.NormalizedCurve = pdf * scaleFactor;
        }

        scatterColorSeries.Clear();

        foreach (var point in selectedPoints)
        {
            var data = new CapabilityData
            {
                SpecificGravity = point.X,
                Value = point.Y
            };

            string label;
            Color color;

            if (point.Y < LSL)
            {
                label = "Below LSL";
                color = Color.Red;
            }
            else if (point.Y > USL)
            {
                label = "Above USL";
                color = Color.Orange;
            }
            else
            {
                label = "Within Spec";
                color = Color.Green;
            }

            // Find or create the group
            var group = scatterColorSeries.FirstOrDefault(g => g.SeriesName == label);
            if (group == null)
            {
                group = new ScatterSeriesGroup
                {
                    SeriesName = label,
                    SeriesColor = color
                };
                scatterColorSeries.Add(group);
            }

            group.Data.Add(data);
        }

        StateHasChanged(); // To trigger chart re-rendering

    }
}
